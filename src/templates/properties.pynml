<!--! some switches are common to all vehicles so included with properties -->

<tal:visual_effect condition="vehicle.unit_requires_visual_effect">
    <tal:include metal:use-macro="load: visual_effect_and_powered.pynml" />
</tal:visual_effect>

<!--! two options for variable power
      these are incompatible with each other as of Dec 2018, but that could be changed in theory
      depends on https://github.com/OpenTTD/OpenTTD/pull/7000 adn refactoring power_by_railtype approach -->
<tal:railtype_varies_power condition="consist.engine_varies_power_by_railtype(vehicle)">
    // -- power varies by railtype -- //
    switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_power, current_railtype) {
        <tal:only_if_overrides_exist condition="consist.power_by_railtype is not None">
            <tal:railtype_specific_effects repeat="railtype consist.power_by_railtype.keys()">
                ${railtype}: return ${consist.power_by_railtype[railtype]};
            </tal:railtype_specific_effects>
        </tal:only_if_overrides_exist>
        return ${consist.power};
    }
    <!--! only useful if this is merged: https://github.com/OpenTTD/OpenTTD/pull/7000 -->
    <!--!switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_power, var[0x6a, 8, 0xFF, ELRL]) {
        1: return 2000; // unfinished eh
        return ${consist.power};
    }-->
    <!--! end variable power -->
</tal:railtype_varies_power>

<tal:wagons_add_power condition="consist.wagons_add_power">
    // -- power varies if specific engines are present in the consist -- //
    <!--! this is unsophisticated and doesn't bother enforcing that the cab unit must be contiguous with appropriate wagons -->
    switch (FEAT_TRAINS, PARENT, ${vehicle.id}_switch_power, [count_veh_id(${consist.cab_id}) > 0]) {
        1: return ${consist.cab_power};
        return 0;
    }
    <!--! ALTERNATIVE METHOD - DEPRECATED? -->
    // -- power varies if specific wagons are attached -- //
    <!--! in principle this could be extended to support multiple types of middle vehicle, but as of Dec 2018 I didn't bother -->
    <!--! note use of PARENT not SELF - we want the whole consist here -->
    <!--!
    switch (FEAT_TRAINS, PARENT, ${vehicle.id}_switch_power, 1) {
        return [${consist.power} + ((count_veh_id(${consist.ids_of_wagons_adding_power[0]}) * ${consist.power}) / count_veh_id(${vehicle.id}))];
    }-->
</tal:wagons_add_power>

item(FEAT_TRAINS, ${vehicle.id}, ${vehicle.numeric_id}) {
    property {
        name:                           ${consist.name};
        climates_available:             NO_CLIMATE; // nml constant
        engine_class:                   ${vehicle.engine_class};
        visual_effect_and_powered:      visual_effect_and_powered(VISUAL_EFFECT_DISABLE, 0, DISABLE_WAGON_POWER);
        introduction_date:              date(${consist.intro_date},01,01); // consist just supplies intro year - openttd randomises intro dates a bit anyway
        cargo_capacity:                 ${vehicle.default_cargo_capacity};
        sprite_id:                      SPRITE_ID_NEW_TRAIN; //enable new graphics - nml constant
        power:                          ${consist.power}hp;
        <tal:speed_is_optional condition="consist.speed is not None">
            speed:                          ${consist.speed}mph;
        </tal:speed_is_optional>
        weight:                         ${consist.weight}ton;
        tractive_effort_coefficient:    ${consist.tractive_effort_coefficient};
        cost_factor:                    0; // use the CB to set this, the prop is capped to max 255, cb is 32k
        running_cost_base:              ${vehicle.running_cost_base};
        running_cost_factor:            0; // use the CB to set this, the prop is capped to max 255, cb is 32k
        refit_cost:                     0; // btw this needs to be 0 if we want autorefit without using cb
        refittable_cargo_classes:       bitmask(${vehicle.refittable_classes});
        non_refittable_cargo_classes:   bitmask(); // don't set non-refittable classes, increases likelihood of breaking cargo support
        cargo_allow_refit:              [${vehicle.get_label_refits_allowed()}];
        cargo_disallow_refit:           [${vehicle.get_label_refits_disallowed()}];
        cargo_age_period:               ${vehicle.cargo_age_period};
        <tal:default_cargo condition="len(consist.default_cargos) > 0">
            default_cargo_type:             ${consist.get_nml_expression_for_default_cargos()};
        </tal:default_cargo>
        misc_flags:                     bitmask(${vehicle.special_flags}); // nml constants
        <tal:dual_headed condition="consist.dual_headed">
            dual_headed:                    ${consist.dual_headed};
        </tal:dual_headed>
        model_life:                     ${consist.model_life};
        retire_early:                   ${consist.retire_early};
        reliability_decay:              20; // default value
        vehicle_life:                   ${consist.vehicle_life};
        length:                         ${vehicle.vehicle_length};
        track_type:                     ${consist.track_type};
    }
    graphics {
        default:                        ${vehicle.id}_switch_graphics;
        purchase:                       ${vehicle.id}_switch_graphics_purchase;
        cost_factor:                    ${consist.buy_cost}; // CB used as it is capped to max 32k, prop is only 255
        running_cost_factor:            ${consist.running_cost}; // CB used as it is capped to max 32k, prop is only 255
        <tal:random_company_colour_swap condition="consist.random_company_colour_swap">
            colour_mapping:                 ${vehicle.id}_switch_colour_mapping;
        </tal:random_company_colour_swap>
        <!--! only use the capacity switches if vehicle carries cargo, makes faster compile (saved about 20% of time) -->
        <tal:optional_capacity_switches condition="vehicle.has_cargo_capacity">
            cargo_capacity:                 ${vehicle.id + '_switch_cargo_capacity'};
            purchase_cargo_capacity:        ${vehicle.id + '_switch_cargo_capacity'};
            loading_speed:                  ${vehicle.id + '_switch_loading_speed'};
        </tal:optional_capacity_switches>
        <!--! no buy menu extra text in this grf by design; extra text is associated with BAD FEATURES -->
        <tal:variable_power condition="consist.engine_varies_power_by_railtype(vehicle) or consist.wagons_add_power">
            power:                          ${vehicle.id}_switch_power;
            purchase_power:                 ${consist.power};
        </tal:variable_power>
        <!--! only use the visual effect switches if needed, saves a couple of seconds on compile -->
        <tal:visual_effect condition="vehicle.unit_requires_visual_effect">
            visual_effect_and_powered:      ${vehicle.get_nml_for_visual_effect_and_powered_cb()};
        </tal:visual_effect>
        <tal:add_articulated_parts condition="vehicle.is_lead_unit_of_consist and len(consist.units) > 1">
            articulated_part: ${consist.id}_articulated_cb_switch;
        </tal:add_articulated_parts>
        additional_text:                ${'string(STR_SPRITES_COMPLETE)' if consist.sprites_complete else 'string(STR_SPRITES_INCOMPLETE)'};
    }
}

<tal:rosters condition="vehicle.is_lead_unit_of_consist">
    if (${consist.get_expression_for_rosters()}) {
        item(FEAT_TRAINS, ${vehicle.id}, ${vehicle.numeric_id}) {
            property {
                climates_available:             ALL_CLIMATES;
            }
        }
    }
</tal:rosters>

// -- end ${vehicle.numeric_id} -- <!--! another comment to aid reading the final nml  -->

