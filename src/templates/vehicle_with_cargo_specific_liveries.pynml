<!--!
    liveries mapped to cargos, but no support here for load states, just one sprite per cargo
    e.g. tank cars with black for oil, cc for chemicals, grey for petrol etc.
-->

<tal:include metal:use-macro="load: spriteset_templates.pynml" />

<!--! this template does not support 'random_reverse' property or 'allow_flip' user-flipping
      cargo vehicles using this template are always symmetrical, no need for extra complexity
      there is an assert for this in train.py -->
// default graphics chain
<tal:cargo_variants repeat="cargo_variant_num python:range(consist.gestalt_graphics.num_cargo_sprite_variants)">
    spriteset(${vehicle.id}_ss_${cargo_variant_num}, "${global_constants.graphics_path}${consist.id}.png") {
      spriteset_template_${vehicle.symmetry_type}_unreversed_${vehicle.id}_unflipped(10 + ${cargo_variant_num * 30})
    }

    spritegroup ${vehicle.id}_sg_${cargo_variant_num} {
        loaded:  [
            ${vehicle.id}_ss_${cargo_variant_num},
        ];
        loading: [
            ${vehicle.id}_ss_${cargo_variant_num},
        ];
    }
</tal:cargo_variants>

<!--! this triggers random on a new load, which was designed for use specifically with containers where colours are randomised on load
      it's not necessary for e.g. tankers, which only have one livery option per cargo
      !! April 2018 - I'm not convinced this is doing what the comment suggests,
         I think it's one and only one remap per cargo label currently, with no option for multiple variants per cargo
         this could probably be simplified
         also containers should just be piece -->
<tal:cargo_random_switches repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
    random_switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_${mapping[0]}, bitmask(TRIGGER_VEHICLE_NEW_LOAD)) {
        <tal:random_graphics_variations repeat="spriterow_num mapping[1]">
            1: return ${vehicle.id}_sg_${spriterow_num};
        </tal:random_graphics_variations>
    }
</tal:cargo_random_switches>

switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_vehicle, cargo_type_in_veh) {
    <tal:cargos repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:exclude_default_cargo condition="mapping[0] != 'DFLT'">
            ${mapping[0]}: return ${vehicle.id}_switch_graphics_${mapping[0]};
        </tal:exclude_default_cargo>
    </tal:cargos>
    <tal:default_cargo repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:block condition="mapping[0] == 'DFLT'">
            return ${vehicle.id}_switch_graphics_${mapping[0]};
        </tal:block>
    </tal:default_cargo>
}

<tal:include metal:use-macro="load: graphics_switches.pynml" />

// buy menu graphics chain
<tal:cargo_variants repeat="cargo_variant_num python:range(consist.gestalt_graphics.num_cargo_sprite_variants)">
    spriteset(${vehicle.id}_ss_purchase_${cargo_variant_num}, "${global_constants.graphics_path}${consist.id}.png") {
      spriteset_template_purchase_${vehicle.id}(10 + ${cargo_variant_num * 30})
    }

    spritegroup ${vehicle.id}_sg_purchase_${cargo_variant_num} {
        loaded:  [
            ${vehicle.id}_ss_purchase_${cargo_variant_num},
        ];
        loading: [
            ${vehicle.id}_ss_purchase_${cargo_variant_num},
        ];
    }
</tal:cargo_variants>

<!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
      if there was nothing specific, then this would just be a null switch, but in this case we switch to the livery for (default) cargo -->
switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_purchase, cargo_type_in_veh) {
    <tal:cargos repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:exclude_default_cargo condition="mapping[0] != 'DFLT'">
            ${mapping[0]}: return ${vehicle.id}_sg_purchase_${mapping[1][0]};
        </tal:exclude_default_cargo>
    </tal:cargos>
    <tal:default_cargo repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:block condition="mapping[0] == 'DFLT'">
            return ${vehicle.id}_sg_purchase_${mapping[1][0]};
        </tal:block>
    </tal:default_cargo>
}
<tal:optional_capacity_switches condition="vehicle.has_cargo_capacity">
    <tal:include metal:use-macro="load: capacity_switches.pynml" />
</tal:optional_capacity_switches>

<tal:include metal:use-macro="load: properties.pynml" />
