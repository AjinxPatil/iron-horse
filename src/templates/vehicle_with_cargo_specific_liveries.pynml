<!--!
    liveries mapped to cargos, but no support here for load states, just one sprite per cargo
    e.g. tank cars with black for oil, cc for chemicals, grey for petrol etc.
-->

<tal:include metal:use-macro="load: spriteset_templates.pynml" />

<!--! 'random_reverse' property is not supported in this template, vehicles using this template are all symmetrical, reversing would do nothing
      'flipped' is user flipping vehicle in depot and *is* supported here (used for livery selection tricks)
      don't conflate them :) -->
// default graphics chain
<tal:cargo_variants repeat="cargo_variant_num python:range(consist.gestalt_graphics.num_cargo_sprite_variants)">
    spriteset(${vehicle.id}_ss_${cargo_variant_num}_unflipped, "${global_constants.graphics_path}${consist.id}.png") {
      spriteset_template_${vehicle.symmetry_type}_unreversed_${vehicle.id}_unflipped(10 + ${cargo_variant_num * 30})
    }
    spriteset(${vehicle.id}_ss_${cargo_variant_num}_flipped, "${global_constants.graphics_path}${consist.id}.png") {
      spriteset_template_${vehicle.symmetry_type}_unreversed_${vehicle.id}_flipped(10 + ${cargo_variant_num * 30})
    }

    // handle user flipped state
    switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_livery_${cargo_variant_num}, vehicle_is_flipped) {
        1: return ${vehicle.id}_ss_${cargo_variant_num}_flipped;
        return ${vehicle.id}_ss_${cargo_variant_num}_unflipped;
    }
</tal:cargo_variants>

<!--! this triggers random on a new load, which was designed for use specifically with containers where colours are randomised on load
      it's not necessary for e.g. tankers, which only have one livery option per cargo
      !! April 2018 - I'm not convinced this is doing what the comment suggests,
         I think it's one and only one remap per cargo label currently, with no option for multiple variants per cargo
         this could probably be simplified
         also containers should just be piece -->
<tal:cargo_random_switches repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
    random_switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_${mapping[0]}, bitmask(TRIGGER_VEHICLE_NEW_LOAD)) {
        <tal:random_graphics_variations repeat="spriterow_num mapping[1]">
            1: return ${vehicle.id}_switch_graphics_livery_${spriterow_num};
        </tal:random_graphics_variations>
    }
</tal:cargo_random_switches>

switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_vehicle, cargo_type_in_veh) {
    <tal:cargos repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:exclude_default_cargo condition="mapping[0] != 'DFLT'">
            ${mapping[0]}: return ${vehicle.id}_switch_graphics_${mapping[0]};
        </tal:exclude_default_cargo>
    </tal:cargos>
    <tal:default_cargo repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:block condition="mapping[0] == 'DFLT'">
            return ${vehicle.id}_switch_graphics_${mapping[0]};
        </tal:block>
    </tal:default_cargo>
}

// buy menu graphics chain
<tal:cargo_variants repeat="cargo_variant_num python:range(consist.gestalt_graphics.num_cargo_sprite_variants)">
    spriteset(${vehicle.id}_ss_purchase_${cargo_variant_num}, "${global_constants.graphics_path}${consist.id}.png") {
      spriteset_template_purchase_${vehicle.id}(10 + ${cargo_variant_num * 30})
    }
</tal:cargo_variants>

<tal:include metal:use-macro="load: graphics_switches.pynml" />

<!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
      if there was nothing specific, then this would just be a null switch, but in this case we switch to the livery for (default) cargo -->
switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_purchase, cargo_type_in_veh) {
    <tal:cargos repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:exclude_default_cargo condition="mapping[0] != 'DFLT'">
            ${mapping[0]}: return ${vehicle.id}_ss_purchase_${mapping[1][0]};
        </tal:exclude_default_cargo>
    </tal:cargos>
    <tal:default_cargo repeat="mapping consist.gestalt_graphics.cargo_row_map.items()">
        <tal:block condition="mapping[0] == 'DFLT'">
            return ${vehicle.id}_ss_purchase_${mapping[1][0]};
        </tal:block>
    </tal:default_cargo>
}
<tal:optional_capacity_switches condition="vehicle.has_cargo_capacity">
    <tal:include metal:use-macro="load: capacity_switches.pynml" />
</tal:optional_capacity_switches>

<tal:include metal:use-macro="load: properties.pynml" />
