<!--!
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    CABBAGE
    Var 41 only checks consecutive chains for a single ID
    This provides an alternative checking consecutive chains using up to 16 IDs
    This checks var 61 many many times in graphics chains, and var 61 is not cached, so this _may_ introduce performance problems
    To use:
        * switch_initialise_alt_var_41() at start of graphics chain
        * read appropriate temp registers to use the alt var
        * the available values are similar to var 41: position from start of chain, position from end of chain, num vehicles in chain
        * LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids})
        * LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_from_end_multiple_ids})
        * LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids})
-->

switch (FEAT_TRAINS, SELF, switch_alternative_var_random_bits_result, getbits(random_bits, LOAD_TEMP(${temp_storage_ids.random_bits_offset}), LOAD_TEMP(${temp_storage_ids.random_bits_count}))) {
    <!--! we need to return the value of the bits, there's probably a better way but eh -->
    <tal:silly_result repeat="result range(1, 256)">
        ${result}: return ${result};
    </tal:silly_result>
    return 0;
}

switch (FEAT_TRAINS, SELF, switch_alternative_var_random_bits, bits_offset, bits_count,
                    [STORE_TEMP(bits_offset, ${temp_storage_ids.random_bits_offset}),
                     STORE_TEMP(bits_count, ${temp_storage_ids.random_bits_count})]) {
    return switch_alternative_var_random_bits_result;
}

