<!--! some switches are common to all vehicles so included with properties -->

<tal:create_effect condition="len(vehicle.effects) > 0">
    <tal:include metal:use-macro="load: create_effect.pynml" />
</tal:create_effect>

<tal:railtype_varies_power condition="consist.engine_varies_power_by_power_source(vehicle) and vehicle.is_lead_unit_of_consist">
    <tal:include metal:use-macro="load: power.pynml" />
</tal:railtype_varies_power>

<tal:wagons_add_power condition="consist.wagons_add_power and vehicle.is_lead_unit_of_consist">
    <tal:include metal:use-macro="load: power.pynml" />
</tal:wagons_add_power>

<tal:easter_egg_haulage_speed_bonus condition="consist.easter_egg_haulage_speed_bonus and vehicle.is_lead_unit_of_consist">
    <tal:include metal:use-macro="load: speed.pynml" />
</tal:easter_egg_haulage_speed_bonus>

<tal:lgv_capable_speed_bonus condition="consist.lgv_capable and vehicle.is_lead_unit_of_consist">
    <tal:include metal:use-macro="load: speed.pynml" />
</tal:lgv_capable_speed_bonus>

<tal:running_cost_factor condition="getattr(consist, 'affected_by_restaurant_car_in_consist', False) and vehicle.is_lead_unit_of_consist">
    <tal:include metal:use-macro="load: cost.pynml" />
</tal:running_cost_factor>

<tal:unit_variants repeat="unit_variant vehicle.unit_variants">
    <tal:buy_menu_additional_text condition="vehicle.is_lead_unit_of_consist and unit_variant.uses_buy_menu_additional_text">
        <tal:include metal:use-macro="load: buy_menu_additional_text.pynml" />
    </tal:buy_menu_additional_text>

    <!--! !!! this could be moved to a dedicated .pynml file, but as of April 2023 I'm not 100% convinced it's done -->
    <tal:variant_name condition="unit_variant.buyable_variant.buyable_variant_group is not None and vehicle.is_lead_unit_of_consist">
        switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_name_purchase_level_0, [1]) {
            ${consist.get_name(context='purchase_level_0', unit_variant=unit_variant)[0]};
        }
        switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_name_purchase_level_1, [1]) {
            return ${consist.get_name(context='purchase_level_1', unit_variant=unit_variant)[0]};
        }
        switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_name_autoreplace_lhs, [1]) {
            return ${consist.get_name(context='autoreplace_lhs', unit_variant=unit_variant)[0]};
        }

        switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_name_purchase_extra_bits, getbits(extra_callback_info1, 8, 8)) {
            0: ${unit_variant.id}_switch_name_purchase_level_0;
            1: ${unit_variant.id}_switch_name_purchase_level_1;
            return CB_RESULT_NO_TEXT; <!--! will use property instead -->
        }
        switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_name, [
                <tal:optional_text_stack condition="len(unit_variant.get_name_text_stack()) > 0">
                    <!--! put 2 colours on the text stack if required, for use in name suffixes -->
                    <tal:text_stack define="colour_procedure_calls unit_variant.get_name_text_stack()">
                        STORE_TEMP(
                            (${colour_procedure_calls[0]} | 0xD000) <!--! OR with 0xD000 to get the correct string range -->
                            | (${colour_procedure_calls[1]} | 0xD000) << 16,
                            0x100
                        ),
                    </tal:text_stack>
                </tal:optional_text_stack>
                <!--! get the context the name callback is called in -->
                getbits(extra_callback_info1, 0, 8)
            ]) {
            0x20: ${unit_variant.id}_switch_name_purchase_extra_bits;
            0x22: ${unit_variant.id}_switch_name_autoreplace_lhs;
            return CB_RESULT_NO_TEXT; <!--! will use property instead -->
        }
    </tal:variant_name>


    item(FEAT_TRAINS, ${unit_variant.id}, ${unit_variant.numeric_id}) {
        property {
            name:                           ${consist.get_name(context="static_property", unit_variant=unit_variant)[0]};
            climates_available:             NO_CLIMATE; // nml constant
            <tal:lead_unit_of_consist_only condition="vehicle.is_lead_unit_of_consist">
                <!--! some properties should not be set for trailing parts of articulated consists -->
                engine_class:                   ${vehicle.engine_class};
                introduction_date:              date(${unit_variant.intro_year}, ${1 + consist.intro_date_months_offset}, 1);
                power:                          ${consist.power}hp;
                weight:                         ${consist.weight}ton;
                tractive_effort_coefficient:    ${consist.tractive_effort_coefficient};
                cost_factor:                    0; // use the CB to set this, the prop is capped to max 255, cb is 32k
                running_cost_base:              ${vehicle.running_cost_base};
                running_cost_factor:            0; // use the CB to set this, the prop is capped to max 255, cb is 32k
                model_life:                     ${consist.model_life};
                retire_early:                   ${consist.retire_early};
                reliability_decay:              20; // default value
                vehicle_life:                   ${consist.vehicle_life};
                <tal:variant_group condition="unit_variant.buyable_variant.get_variant_group_parent_vehicle_id() is not None">
                    variant_group:                  ${unit_variant.buyable_variant.get_variant_group_parent_vehicle_id()};
                </tal:variant_group>
            </tal:lead_unit_of_consist_only>
            <tal:trailing_parts_of_consist_only condition="not vehicle.is_lead_unit_of_consist">
                <!--! some properties must be explicitly set to 0 for trailing parts -->
                <!--! note that power cannot be 0 for engines, even this violates spec as of Nov 2022
                      - for details see https://github.com/OpenTTD/OpenTTD/issues/10146 -->
                power:                          ${1 if consist.power != 0 else 0};
                weight:                         0;
                tractive_effort_coefficient:    0;
                cost_factor:                    0;
                running_cost_base:              RUNNING_COST_NONE;
                running_cost_factor:            0;
            </tal:trailing_parts_of_consist_only>
            <tal:speed_is_optional condition="consist.speed is not None">
                speed:                          ${consist.speed}mph;
            </tal:speed_is_optional>
            cargo_capacity:                 ${vehicle.default_cargo_capacity};
            sprite_id:                      SPRITE_ID_NEW_TRAIN; //enable new graphics - nml constant
            refit_cost:                     0; // btw this needs to be 0 if we want autorefit without using cb
            refittable_cargo_classes:       bitmask(${vehicle.refittable_classes});
            non_refittable_cargo_classes:   bitmask(); // don't set non-refittable classes, increases likelihood of breaking cargo support
            cargo_allow_refit:              [${vehicle.get_label_refits_allowed()}];
            cargo_disallow_refit:           [${vehicle.get_label_refits_disallowed()}];
            <tal:default_cargo condition="len(consist.default_cargos) > 0">
                default_cargo_type:             ${consist.get_nml_expression_for_default_cargos()};
            </tal:default_cargo>
            misc_flags:                     bitmask(${vehicle.misc_flags});
            extra_flags:                    bitmask(${vehicle.get_extra_flags(unit_variant)});
            dual_headed:                    ${1 if consist.dual_headed else 0};
            length:                         ${vehicle.vehicle_length};
            track_type:                     ${consist.track_type};
            effect_spawn_model_and_powered: EFFECT_SPAWN_MODEL_NONE; // default to none to suppress effects, set in cb as needed
        }
        graphics {
            default:                        ${vehicle.id}_switch_graphics;
            purchase:                       ${vehicle.id}_switch_graphics_purchase;
            <tal:lead_unit_of_consist_only condition="vehicle.is_lead_unit_of_consist">
                <tal:variant_name condition="unit_variant.buyable_variant.buyable_variant_group is not None">
                    name:                           ${unit_variant.id}_switch_name;
                </tal:variant_name>
                <!--! certain callbacks should not be handled for trailing parts of articulated consists -->
                cost_factor:                    ${consist.buy_cost}; // CB used as it is capped to max 32k, prop is only 255
                <tal:running_cost_factor switch="getattr(consist, 'affected_by_restaurant_car_in_consist', False)">
                    // CB should be used even for static running costs as it is capped to max 32k, prop is only 255
                    <tal:block case="True">
                        running_cost_factor:            ${vehicle.id}_switch_running_cost_factor;
                    </tal:block
                    <tal:block case="False">
                        running_cost_factor: ${consist.running_cost};
                    </tal:block>
                </tal:running_cost_factor>
                purchase_running_cost_factor:   ${consist.running_cost}; // purchase set separately to prevent unreliable results from trying to access non-available vars for variable run costs
                <tal:variable_power condition="consist.engine_varies_power_by_power_source(vehicle) or consist.wagons_add_power">
                    power:                          ${vehicle.id}_switch_power_0;
                    purchase_power:                 ${consist.power};
                </tal:variable_power>
                <tal:speed_is_optional condition="consist.easter_egg_haulage_speed_bonus or consist.lgv_capable">
                    speed:                          ${vehicle.id}_switch_speed;
                    purchase_speed:                 ${int(1.60934 * consist.speed)};
                </tal:speed_is_optional>
                <tal:add_articulated_parts condition="len(consist.units) > 1">
                    articulated_part: ${consist.id}_variant_${unit_variant.buyable_variant.buyable_variant_num}_articulated_cb_switch;
                </tal:add_articulated_parts>
                <!--! setting buy menu text for engines and some wagons with role set currently - this is starting to look jank AF eh-->
                <tal:buy_menu_additional_text condition="unit_variant.uses_buy_menu_additional_text">
                    additional_text:                ${unit_variant.id}_switch_buy_menu_additional_text;
                </tal:buy_menu_additional_text>
            </tal:lead_unit_of_consist_only>
            <tal:conditional_random_trigger condition="vehicle.random_trigger_switch is not None">
                <!--! NOTE that dual headed units should avoid random triggers as of Dec 2020 - there is an undiagnosed with bug rear unit running unwanted triggers and re-randomising in depots etc -->
                random_trigger:                 ${vehicle.id + vehicle.random_trigger_switch};
            </tal:conditional_random_trigger>
            <tal:colour_mapping_cb switch="vehicle.requires_colour_mapping_cb">
                <tal:use_colour_randomisation_strategies case="'use_colour_randomisation_strategies'">
                    colour_mapping:                 switch_colour_mapping(${unit_variant.get_wagon_recolour_strategy_params()});
                    purchase_colour_mapping:        switch_colour_mapping(${unit_variant.get_wagon_recolour_strategy_params(context="purchase")});
                </tal:use_colour_randomisation_strategies>
                <tal:colour_mapping_switch_without_purchase case="'colour_mapping_switch_without_purchase'">
                    colour_mapping:                 ${vehicle.id + consist.gestalt_graphics.colour_mapping_switch};
                    <!--! in the case of flippable vehicles, don't check colour mapping in purchase list as vehicle_is_flipped is invalid for purchase list and will return 1 as undefined behaviour -->
                    purchase_colour_mapping:        return base_sprite_2cc + 16 * company_colour2 + company_colour1;
                </tal:colour_mapping_switch_without_purchase>
                <tal:colour_mapping_switch_with_purchase case="'colour_mapping_switch_with_purchase'">
                    colour_mapping:                 ${vehicle.id + consist.gestalt_graphics.colour_mapping_switch};
                    purchase_colour_mapping:        ${vehicle.id + consist.gestalt_graphics.colour_mapping_switch_purchase};
                </tal:colour_mapping_switch_with_purchase
            </tal:colour_mapping_cb>
            <!--! only use the capacity switches if vehicle carries cargo, makes faster compile (saved about 20% of time) -->
            <tal:optional_capacity_switches condition="vehicle.has_cargo_capacity">
                cargo_capacity:                 ${vehicle.id + '_switch_cargo_capacity'};
                purchase_cargo_capacity:        ${vehicle.id + '_switch_cargo_capacity'};
                loading_speed:                  ${vehicle.loading_speed};
            </tal:optional_capacity_switches>
            <!--! as of May 2021 cargo subtype use is specific to vehicles transporters, extend in future if needed -->
            <tal:optional_cargo_subtype condition="getattr(consist, 'use_cargo_subytpes_VEHI', False)">
                cargo_subtype_text: switch_cargo_subtype_text();
            </tal:optional_cargo_subtype>
            <!--! only use the visual effect switches if needed, saves a couple of seconds on compile -->
            <tal:create_effect condition="len(vehicle.effects) > 0">
                effect_spawn_model_and_powered: ${vehicle.id}_switch_effect_spawn_model_and_powered;
                create_effect:      ${vehicle.switch_id_for_create_effect};
            </tal:create_effect>
        }
    }

    <tal:rosters condition="vehicle.is_lead_unit_of_consist">
        if (${consist.get_expression_for_availability()}) {
            item(FEAT_TRAINS, ${unit_variant.id}, ${unit_variant.numeric_id}) {
                property {
                    climates_available:             ALL_CLIMATES;
                }
            }
        }
    </tal:rosters>
</tal:unit_variants>
