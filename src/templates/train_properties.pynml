<!--! some switches are common to all vehicles so included with properties -->

<tal:visual_effect condition="vehicle.unit_requires_visual_effect">
    <tal:include metal:use-macro="load: visual_effect_and_powered.pynml" />
</tal:visual_effect>

<tal:variable_power condition="consist.unit_requires_variable_power(vehicle)">
    // -- power -- //
    switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_power, current_railtype) {
        <tal:only_if_overrides_exist condition="consist.power_by_railtype is not None">
            <tal:railtype_specific_effects repeat="railtype consist.power_by_railtype.keys()">
                ${railtype}: return ${consist.power_by_railtype[railtype]};
            </tal:railtype_specific_effects>
        </tal:only_if_overrides_exist>
        return ${consist.power};
    }
    <!--! end variable power -->
</tal:variable_power>


item(FEAT_TRAINS, ${vehicle.id}, ${vehicle.numeric_id}) {
    property {
        name:                           ${consist.get_name()};
        climates_available:             NO_CLIMATE; // nml constant
        engine_class:                   ${vehicle.engine_class};
        visual_effect_and_powered:      visual_effect_and_powered(VISUAL_EFFECT_DISABLE, 0, DISABLE_WAGON_POWER);
        introduction_date:              date(${consist.intro_date},01,01); // consist just supplies intro year - openttd randomises intro dates a bit anyway
        cargo_capacity:                 ${vehicle.default_cargo_capacity};
        sprite_id:                      SPRITE_ID_NEW_TRAIN; //enable new graphics - nml constant
        power:                          ${consist.power}hp;
        <tal:speed_is_optional condition="consist.speed is not None">
            speed:                          ${consist.speed}mph;
        </tal:speed_is_optional>
        weight:                         ${consist.weight}ton;
        tractive_effort_coefficient:    ${consist.tractive_effort_coefficient};
        cost_factor:                    ${consist.buy_cost};
        running_cost_base:              ${vehicle.running_cost_base};
        running_cost_factor:            ${consist.running_cost};
        refit_cost:                     0; // btw this needs to be 0 if we want autorefit without using cb
        refittable_cargo_classes:       bitmask(${vehicle.refittable_classes});
        non_refittable_cargo_classes:   bitmask(); // don't set non-refittable classes, increases likelihood of breaking cargo support
        cargo_allow_refit:              [${vehicle.get_label_refits_allowed()}];
        cargo_disallow_refit:           [${vehicle.get_label_refits_disallowed()}];
        default_cargo_type:             ${vehicle.default_cargo};
        cargo_age_period:               ${vehicle.cargo_age_period};
        misc_flags:                     bitmask(${vehicle.special_flags}); // nml constants
        dual_headed:                    ${consist.dual_headed};
        model_life:                     ${consist.model_life};
        retire_early:                   -10;
        reliability_decay:              20; // default value
        vehicle_life:                   ${consist.vehicle_life};
        length:                         ${vehicle.vehicle_length};
        track_type:                     ${consist.track_type};
    }
    graphics {
        default:                        ${vehicle.id}_switch_graphics;
        purchase:                       ${vehicle.id}_sg_purchase;
        <!--! only use the capacity switches if vehicle carries cargo, makes faster compile (saved about 20% of time) -->
        <tal:optional_capacity_switches condition="vehicle.has_cargo_capacity">
            cargo_capacity:                 ${vehicle.id + '_switch_cargo_capacity'};
            purchase_cargo_capacity:        ${vehicle.id + '_switch_cargo_capacity'};
            loading_speed:                  ${vehicle.id + '_switch_loading_speed'};
        </tal:optional_capacity_switches>
        <!--! no buy menu extra text in this grf by design; extra text is associated with BAD FEATURES -->
        <tal:variable_power condition="consist.unit_requires_variable_power(vehicle)">
            power:                          ${vehicle.id}_switch_power;
            <!--! railtype is not available in purchase menu, so just use the static property (usually set to the lowest power to avoid disappointment after building) -->
            purchase_power:                 ${consist.power};
        </tal:variable_power>
        <!--! only use the visual effect switches if needed, saves a couple of seconds on compile -->
        <tal:visual_effect condition="vehicle.unit_requires_visual_effect">
            visual_effect_and_powered:      ${vehicle.get_nml_for_visual_effect_and_powered_cb()};
        </tal:visual_effect>
        <tal:add_articulated_parts condition="vehicle.is_lead_unit_of_consist and len(consist.units) > 1">
            articulated_part: ${consist.id}_articulated_cb_switch;
        </tal:add_articulated_parts>
    }
}

<tal:rosters condition="vehicle.is_lead_unit_of_consist">
    if (${consist.get_expression_for_rosters()}) {
        item(FEAT_TRAINS, ${vehicle.id}, ${vehicle.numeric_id}) {
            property {
                climates_available:             ALL_CLIMATES;
            }
        }
    }
</tal:rosters>

// -- end ${vehicle.numeric_id} -- <!--! another comment to aid reading the final nml  -->

