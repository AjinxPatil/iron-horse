# spritelayer cargos are sandboxed into their own module to avoid them spawning tentacles into train.py etc

from gestalt_graphics.pipelines import GenerateSpritelayerCargos
from gestalt_graphics.gestalt_graphics import GestaltGraphicsAutomobileTransporter


class AutomobileCargoGestalt(object):
    """Base class for automobile cargos gestalts """

    # a gestalt is a set of automobile cargos (trucks etc.) of specific length and appearance
    # each set corresponds to a spritesheet which will be generated by the graphics processor
    # each set is used for a specific group of cargo labels
    # ====== #

    # each gestalt is named for a type of vehicles cargo, e.g. trucks, cars, tractors, bulldozers etc
    # each gestalt is for a specific length, 16px, 24px, 32px
    # each gestalt has variants
    # each variant is composed from source spritesheets
    # e.g. small truck cc, small truck blue, box truck, etc
    # each variant has n rows, corresponding to a standard number of date changes
    # the date change rows are provided directly in each source spritesheet
    # each variant is asssociated with one of the templates that contain location pixels for the cargo sprites

    # there is a mapping of gestalts to cargo labels and a default

    # !!!!!! are these up to date for vehicles - remove this when done !!!!!

    # each container set may have one or more spriterows
    # spriterows are chosen randomly when vehicles load new cargo
    # rows are composed by the graphics processor, and may include variations for
    # - combinations of container lengths
    # - combinations of container types
    # - container colours
    # !!! containers are going to need 'base sets' to allow double stack, cropped for well cars etc
    # !!! the consist needs to encode the set type to fetch the right spritesets
    # !!! base sets will also have to be encoded in gestalts here, unless they're done by (sets * gestalts) combinatorially?
    def __init__(self, **kwargs):
        self.pipeline = GenerateSpritelayerCargos()
        self.automobile_cargo_subtype = kwargs.get("automobile_cargo_subtype", None)
        self.platform_type = kwargs.get("platform_type", None)

    @property
    def all_platform_types_with_floor_heights(self):
        # extend this when adding more platform types
        # y offset: positive = down in spritesheet (y origin at top)
        return {"default": 0, "low_floor": 1, "cargo_sprinter": 0}

    @property
    def all_platform_types(self):
        return self.all_platform_types_with_floor_heights.keys()

    @property
    def floor_height_for_platform_type(self):
        # crude resolution of floor height for each platform type
        return self.all_platform_types_with_floor_heights[self.platform_type]

    @property
    def id(self):
        return (
            "automobile_cargo_"
            + self.platform_type
            + "_"
            + self.automobile_cargo_subtype
            + "_"
            + str(self.length)
            + "px"
        )


class AutomobileCargoBaseDefaultAndLowFloor(AutomobileCargoGestalt):
    """ Sparse base class to set compatible platform types and sprite placement template """

    # class properties, we want them available without __init__ for...reasons
    compatible_platform_types = ["default", "low_floor"]
    template_type_name = "default"


class Trucks16px(AutomobileCargoBaseDefaultAndLowFloor):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.length = 16
        self.variants = [["trucks_1_1CC"], ["trucks_1_1CC"], ["trucks_1_1CC"]]


class Trucks20px(AutomobileCargoBaseDefaultAndLowFloor):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.length = 20
        self.variants = [["trucks_1_1CC"], ["trucks_1_1CC"], ["trucks_1_1CC"]]


class Trucks24px(AutomobileCargoBaseDefaultAndLowFloor):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.length = 24
        self.variants = [["trucks_1_1CC", "trucks_1_1CC"], ["trucks_1_1CC"]]


class Trucks32px(AutomobileCargoBaseDefaultAndLowFloor):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.length = 32
        self.variants = [
            ["trucks_1_1CC", "trucks_1_1CC", "trucks_1_1CC"],
            ["trucks_1_1CC", "trucks_1_1CC", "trucks_1_1CC"],
        ]


def get_automobile_cargo_gestalts_by_length(vehicle_length):
    result = []
    for automobile_cargo_gestalt in registered_automobile_cargo_gestalts:
        if automobile_cargo_gestalt.length == 4 * vehicle_length:
            result.append(automobile_cargo_gestalt)
    return result


# this is simply manually maintained, and is to prevent nml warnings about unused switches
# suppression_list = [("cargo_sprinter", 16), ("cargo_sprinter", 24)]
suppression_list = []

registered_automobile_cargo_gestalts = []

automobile_cargo_type_gestalt_mapping = {"box": [Trucks16px, Trucks24px, Trucks32px]}


def register_automobile_cargo_gestalt(automobile_cargo_type, automobile_cargo_subtype):
    for gestalt in automobile_cargo_type_gestalt_mapping[automobile_cargo_type]:
        registered_automobile_cargo_gestalts.append(gestalt)


def register_automobile_cargo_gestalt(automobile_cargo_type, automobile_cargo_subtype):
    for gestalt_type in automobile_cargo_type_gestalt_mapping[automobile_cargo_type]:
        for platform_type in gestalt_type.compatible_platform_types:
            gestalt = gestalt_type(
                automobile_cargo_subtype=automobile_cargo_subtype,
                platform_type=platform_type,
            )
            # suppression of unused gestalts to prevent nml warnings further down the chain
            if (platform_type, gestalt.length) not in suppression_list:
                registered_automobile_cargo_gestalts.append(gestalt)


def get_automobile_cargo_gestalts_matching_platform_type_and_length(
    platform_type, platform_length
):
    result = []
    for gestalt in registered_automobile_cargo_gestalts:
        if (gestalt.platform_type == platform_type) and (
            gestalt.length == platform_length
        ):
            result.append(gestalt)
    return result


def gestalt_has_random_variants_for_cargo_label(
    platform_type, platform_length, automobile_cargo_subtype
):
    result = False
    for gestalt in get_automobile_cargo_gestalts_matching_platform_type_and_length(
        platform_type, platform_length
    ):
        if gestalt.automobile_cargo_subtype == automobile_cargo_subtype:
            if len(gestalt.variants) > 1:
                result = True
    return result


def get_next_cargo_switch(platform_type, platform_length, automobile_cargo_subtype):
    # this is solely to optimise out pointless random switches, which nml could do for us but eh, why not shave the yak :P
    if gestalt_has_random_variants_for_cargo_label(
        platform_type, platform_length, automobile_cargo_subtype
    ):
        return (
            "switch_spritelayer_cargos_automobile_transporter_cars_random_"
            + platform_type
            + "_"
            + str(platform_length)
            + "px_"
            + automobile_cargo_subtype
        )
    else:
        return (
            "switch_spritelayer_cargos_automobile_transporter_cars_"
            + platform_type
            + "_"
            + str(platform_length)
            + "px_"
            + automobile_cargo_subtype
            + "_0"
        )


def main():
    # yeah this is fiddly
    # we need to generate both cargo-specific sprites (visible cargo or specific recolour
    # and semi-generic fallback sprites, with specific type of container - tank, box, etc (and generic cargo and/or default recolour)
    # first do the defaults, which will be named xxxxxx_DFLT

    # !! not clear that we need the subtypes in this way, there's no cargo-specific variation once we're into the automobile_cargo_type

    for automobile_cargo_type in automobile_cargo_type_gestalt_mapping.keys():
        if automobile_cargo_type not in [
            "bulk"
        ]:  # exclude some types which have no meaningful default (and will fall back to box)
            automobile_cargo_subtype = automobile_cargo_type + "_DFLT"
            register_automobile_cargo_gestalt(
                automobile_cargo_type, automobile_cargo_subtype
            )

    """
    commented by design, this is just for debugging / project management
    # for knowing how many containers combinations we have in total
    total = 0
    for gestalt in registered_automobile_cargo_gestalts:
        total += len(gestalt.variants)
    print('total variants', total)
    """
