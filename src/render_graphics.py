#!/usr/bin/env python

"""
  This file is part of Iron Horse Newgrf for OpenTTD.
  Iron Horse is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
  Iron Horse is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Iron Horse. If not, see <http://www.gnu.org/licenses/>.
"""
print("[RENDER GRAPHICS] render_graphics.py")

import codecs # used for writing files - more unicode friendly than standard open() module

import shutil
import os
currentdir = os.curdir
import sys
from multiprocessing import Pool
import multiprocessing
logger = multiprocessing.log_to_stderr()
logger.setLevel(25)

import utils
# get args passed by makefile
repo_vars = utils.get_repo_vars(sys)
num_pool_workers = repo_vars.get('num_pool_workers', 1)
if num_pool_workers == 0:
    use_multiprocessing = False
else:
    use_multiprocessing = True

import iron_horse

graphics_input = os.path.join(currentdir, 'src', 'graphics')
graphics_output_path = os.path.join(iron_horse.generated_files_path, 'graphics')
if os.path.exists(graphics_output_path):
    shutil.rmtree(graphics_output_path)
os.mkdir(graphics_output_path)

hint_file = codecs.open(os.path.join(graphics_output_path, '_graphics_files_here_are_generated.txt'), 'w','utf8')
hint_file.write("Don't edit the graphics files here.  They're generated by the build script. \n Edit sources in graphics_sources and export spritesheets to graphics_input.")
hint_file.close()

def run_pipeline(items):
    variant = items[0]
    consist = items[1]
    if variant.graphics_processor is None:
        shutil.copy(os.path.join(graphics_input, variant.get_spritesheet_name(consist)), graphics_output_path)
    else:
        result = variant.graphics_processor.pipeline.render(variant, consist)
        return result

# wrapped in a main() function so this can be called explicitly, because unexpected multiprocessing fork bombs are bad
def main():
    consists = iron_horse.get_consists_in_buy_menu_order()
    variants = []
    for consist in consists:
        for variant in consist.model_variants:
            variants.append((variant, consist))

    # in local tests, using more workers (up to 16) results in faster graphics rendering for me
    if use_multiprocessing == False:
        for variant in variants:
            run_pipeline(variant)
    else:
        pool = Pool(processes=num_pool_workers)
        pool.map(run_pipeline, variants)
        pool.close()

    # handle special case spritesheets
    shutil.copy(os.path.join(graphics_input, 'null_trailing_part.png'), graphics_output_path)

if __name__ == '__main__':
    main()
